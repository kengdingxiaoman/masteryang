# JAVA开发手册

## 概述
本文针对所有使用JAVA语言开发的开发人员

# 编程规范

## 命名风格

- 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。
- 代码中的命名严禁使用拼音与英文混合的方式，避免使用拼音命名，更不允许使用拼音首字母拼接的结果来命名<br/>
  例如：int cbhs  表示的是'成本核算'，这样是绝对不可以的
- 类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外： DO / BO / DTO / VO / AO
- 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。
- 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长
- 抽象类命名使用 Abstract 或 Base 开头； 异常类命名使用 Exception 结尾； 测试类命名以它要测试的类的名称开始，以 Test 结尾。
- 中括号是数组类型的一部分，数组定义如下： <font color="blue">String[]</font> args;不应使用 String args[]的方式来定义
- POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误<br/>
  例如：定义为基本数据类型 Boolean isDeleted； 的属性，它的方法也是 isDeleted()，RPC框架在反向解析的时候，"以为"对应的属性名称是 deleted，导致属性获取不到，进而抛出异常
- 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。
- 如果使用到了设计模式，建议在类名中体现出具体模式<br/>
  例如：XXXXFactory, XXXXProxy等
- 接口类中的方法和属性不要加任何修饰符号(public 也不要加)，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。
- 接口和实现类的命名使用如下规则：<br/>
对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别，例如：PayService, PayServiceImpl, UserBaseDao, UserBaseDaoImpl
- 枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开
- 各层命名规约：
  1. Service/DAO 层方法命名约定<br/>
a. 获取单个对象的方法用 get 做前缀<br/>
b. 获取多个对象的方法用 finds 做前缀<br/>
b. 分页形式获取多个对象的方法用 queryPaged 做前缀<br/>
c. 获取统计值的方法用 count, sum 做前缀<br/>
d. 插入的方法用 insert 做前缀<br/>
e. 删除的方法用 delete 做前缀<br/>
f. 修改的方法用 update 做前缀<br/>

  2. 领域模型命名规约<br/>
a. 数据对象： xxxDO， xxx 即为数据表名，对象属性和数据库表中字段一一对应<br/>
b. 数据传输对象： xxxDTO， xxx为业务领域相关的名称<br/>
c. 展示对象： xxxVO， 用来封装展示到页面的元素<br/>
d. 领域对象：xxx，xxx对应数据表名，做为领域对象
e. POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO

## 常量定义
- 不允许任何魔数(magic number, 即未经定义的常量)直接出现在代码中<br/>
例如：String num = 5;
- long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解<br/>
- 不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护
- 如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类，例如星期几

## 代码格式
- 大括号的使用约定：
  1. 如果是大括号内为空，也需要换行
  2. 左大括号前不换行，左大括号后换行
  3. 右大括号前换行，右大括号后还有 else 等代码则不换行； 表示终止的右大括号后必须换行
- 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格
- if/for/while/switch/do 等保留字与括号之间都必须加空格
- 任何二目、 三目运算符的左右两边都需要加一个空格
- 缩进采用 4 个空格，必须使用缩进
- 单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：
  1. 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例
  2. 运算符与下文一起换行
  3. 方法调用的点符号与下文一起换行
  4. 在多个参数超长， 在逗号后换行
  5. 在括号前不要换行
- 方法参数在定义和传入时，多个参数逗号后边必须加空格
- IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式
- 没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐
- 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行

## OOP 规范
- 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可
- 所有的覆写方法，必须加 /@Override 注解
- 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object, 可变参数必须放置在参数列表的最后，尽量少使用可变参数
- 接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么
- 不能使用过时的类或方法，寻找使用新的类和方法
- Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals<br/>
例如："test".equals(str)
- 所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较
- 关于基本数据类型与包装数据类型的使用标准如下：
  1. 所有的 POJO 类属性必须使用包装数据类型。
  2. RPC 方法的返回值和参数必须使用包装数据类型。
  3. 所有的局部变量使用基本数据类型
- 定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值
- 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中
- POJO 类必须写 toString 方法
- 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读
- 类内方法定义顺序依次是：公有方法或保护方法 -> 私有方法 -> getter/setter方法
- setter 方法中，参数名称与类成员变量名称一致， this.成员名 = 参数名。在getter/setter 方法中， 不要增加业务逻辑，增加排查问题的难度，如果有业务逻辑的，不要使用getXXX()
- 循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展
- final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：
  1. 不允许被继承的类，如： String 类。
  2. 不允许修改引用的域对象，如： POJO 类的域变量。
  3. 不允许被重写的方法，如： POJO 类的 setter 方法。
  4. 不允许运行过程中重新赋值的局部变量。
  5. 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构
- 类成员与方法访问控制从严：
  1. 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。
  2. 工具类不允许有 public 或 default 构造方法。
  3. 类非 static 成员变量并且与子类共享，必须是 protected。
  4. 类非 static 成员变量并且仅在本类使用，必须是 private。
  5. 类 static 成员变量如果仅在本类使用，必须是 private。
  6. 若是 static 成员变量，必须考虑是否为 final。
  7. 类成员方法只供类内部调用，必须是 private。
  8. 类成员方法只对继承类公开，那么限制为 protected

## 集合处理
- 关于 hashCode 和 equals 的处理，遵循如下规则：
  1. 只要重写 equals，就必须重写 hashCode。
  2. 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的
对象必须重写这两个方法。
  3. 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。
- ArrayList的subList结果不可强转成ArrayList，否则会抛出 ClassCastException，subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList
- 在 subList 场景中， <font color="blue">高度注意</font>对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException 异常
- 使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()
- 使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常
- 泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用 add 方法， 而<? super T>不能使用 get 方法，做为接口调用赋值时易出错
- 不要在 foreach 循环里进行元素的 remove/add 操作。 remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁
- Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常
  1. x， y 的比较结果和 y， x 的比较结果相反。
  2. x>y， y>z， 则 x>z。
  3. x=y， 则 x， z 比较结果和 y， z 比较结果相同
- 集合初始化时，指定集合初始值大小
- 使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历
- 高度注意 Map 类集合 K/V 能不能存储 null 值的情况
- 合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响
- 利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains 方法进行遍历、对比、 去重操作

## 并发处理
- 获取单例对象需要保证线程安全，其中的方法也要保证线程安全
- 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程
- 线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险
- SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为static，必须加锁，或者使用 DateUtils 工具类
- 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁
- 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁
- 并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次
- 多线程并行处理定时任务时， Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题
- 使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果
- 避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降
- 在并发场景下， 通过双重检查锁(double-checked locking) 实现延迟初始化的优化问题隐患(可参考 The "Double-Checked Locking is Broken" Declaration)， 推荐问题解决方案中较为简单一种，将目标属性声明为 volatile 型
- HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险
- ThreadLocal 无法解决共享对象的更新问题， ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量

## 控制语句
- 在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止； 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有
- 在 if/else/for/while/do 语句中必须使用大括号。 即使只有一行代码，不允许使用单行的形式：<br/>
反例：if (condition) statements， 必须换行
- 理论上嵌套不允许超过3层
- 除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性(具体会在可读代码一文中进行描述)
- 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作

## 注释
- 类、属性、方法的注释必须使用 Javadoc 规范，使用\/\*\*内容\*\/格式，不得使用\/\/xxx 方式
- 所有的抽象方法(包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能
- 类，属性，方法一般都需要写注释，有些可以除外，例如：get, set方法
- 所有的类都必须添加创建者和创建日期
- 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用\/\* \*\/注释，注意与代码对齐
- 所有的枚举类型字段必须要有注释，说明每个数据项的用途
- 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改
- 不应有注释了的代码，无用的代码应该进行删除
- 特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码：
  1. 待办事宜(TODO) :（标记人，标记时间， [预计处理时间]）表示需要实现，但目前还未实现的功能
  2. 错误，不能工作(FIXME) :(标记人，标记时间， [预计处理时间])

## 其他
- 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度
- 注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x<1(能够取到零值，注意除零异常)， 如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法
- 获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime()
- 任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存
- 对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾

# 异常和日志

## 异常
- Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： IndexOutOfBoundsException， NullPointerException 等等
- 异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低
- 对大段代码进行 try-catch，这是不负责任的表现。 catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理
- 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容
- finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch
- 不能在 finally 块中使用 return， finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句
- 捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类
- 方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题
- 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：
  1. 返回类型为基本数据类型， return 包装数据类型的对象时，自动拆箱有可能产生 NPE。
  2. 数据库的查询结果可能为 null。
  3. 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。
  4. 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。
  5. 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。
  7. 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE
- 定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如： DAOException / ServiceException 等
- 提供的对外接口不应抛出异常，如果程序内发生异常，应返回响应的错误码

## 日志
- 应用中不可直接使用日志系统(Log4j、 Logback)中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一
- 日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点
- 对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式
- 异常信息必须打印堆栈信息

# 数据库

## SQL语句
